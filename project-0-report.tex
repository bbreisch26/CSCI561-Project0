
\documentclass[12pt,letterpaper]{ntdhw}

\usepackage{graphicx}
\graphicspath{ {./images/} }



\title{Project 0: Functional Programming and Lisp Introduction}
\author{CSCI 561}

\rhead{Names: Luke Beukelman, Ben Breisch, Luc Lafave, Adam Thistlewood}

%\keytrue

\begin{document}
\pagestyle{fancyplain}

\maketitle
\thispagestyle{fancyplain}
%\clearpage

\begin{enumerate}

  \item What are the result types of the following Lisp expressions?
  \begin{enumerate}
    \item {\tt 1} : \emph{
      INTEGER
    }
    \item {\tt (+ 1 2)} : \emph{
      INTEGER
    }
    \item {\tt '(+ 1 2)} : \emph{
      LIST
    }
    \item {\tt (eval '(+ 1 2))} : \emph{
      INTEGER
    }
    \item {\tt (lambda () (+ 1 2))} : \emph{
      FUNCTION
    }
    \item {\tt "foo"} : \emph{
      STRING/ARRAY
    }
    \item {\tt 'bar} : \emph{
      SYMBOL
    }
  \end{enumerate}

  \item Tail Calls:
  \begin{enumerate}
    \item What is tail recursion?

    \begin{emph}
      Answer: Tail recursion occurs when the recursive call is the last operation of a function.
    \end{emph}

    \item In the recursive implementation, will {\tt fold-left} or
    {\tt fold-right} be more memory-efficient?  Why?

    \begin{emph}
      Answer: Fold-left will be more memory efficient because fold-right uses a large function call stack while fold-left processes on the go.
    \end{emph}
  \end{enumerate}

  \item Lisp and Python represent code differently.

  \begin{enumerate}
    \item Contrast the representations of Lisp code and Python code.

    \begin{emph}
      Answer: % Your Answer Here
    \end{emph}

    \item How do Python's {\tt eval()} and {\tt exec()} differ from
    the approach of Lisp?

    \begin{emph}
      Answer: % Your Answer Here
    \end{emph}
  \end{enumerate}

  \item GCC supports an extension to the C language that allows
  local/nested functions (functions contained in other functions).  A
  GCC local function can access local variables from its parent
  function.
  \begin{enumerate}
    \item What problems could arise if you return a function pointer
    to a GCC local function? \emph{(Hint: ``Funarg problem'')}

    \begin{emph}
      Answer: % Your Answer Here
    \end{emph}

    \item How does Lisp handle this problem?

    \begin{emph}
      Answer: % Your Answer Here
    \end{emph}

  \end{enumerate}


  \item Test the performance of your implementation of
    \texttt{merge-sort}.
    \begin{enumerate}
    \item Plot the running time of your \texttt{merge-sort}
      implementation for increasing input sizes.  Include enough data
      points to demonstrate the empirical asymptotic running time.

    \begin{emph}
      Answer: % Your Answer Here 
      \break \includegraphics{merge} \break
      The graph above shows the average of 5 runs of merge-sort for an increasing value of n. Values within a test list of length n were generated using Common Lisp's \(RANDOM\) function. The graph also shows a theoretical \(n*log(n)\) on a secondary axis.
      
    \end{emph}

    \item What asymptotic running time did you expect for
      \texttt{merge-sort}, and what running time did you observe?
      Explain any differences.

    \begin{emph}
      Answer: % Your Answer Here
      Merge-sort has an average runtime complexity of \(\theta (n*log(n))\). As you can see in the graph above, the runtime of our algorithm very nearly matches the theoretical complexity of the algorithm. Some explanations for the small amount of error include CPU clock speed variations, scheduling discrepancies, as well as competing processes. All development and testing was done on Isengard, a shared server that has many users.
    \end{emph}

    \end{enumerate}

\end{enumerate}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
